---
title: "Cha4多组数据位置推断"
author: "Haozhe_Pang"
date: "4/23/2021"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# 4.2 Kruskal-Wallis 单因素方差分析
其中分别包括两部分，分别是Kruskal-wallis检验和dunn检验
首先定义dunn.test
```{r}
dunn.test<-function(data,treat,alpha,...){
  #首先是准备工作，分别需要定义处理内平均秩；结点出现时对MST、SE修正
  x = data
  n = length(x) ##数据总个数
  k = length(unique(treat)) ##类别数
  # 若abs(d_ij) >= Z_{1-alphastar}，则表示第i和第j处理见有显著差异
  alphastar = alpha/(choose(k,2)*2)
  Z = qnorm(1-alphastar)
  
  #接下来计算秩均值
  # 每一次计算都要初始化
  rank<- NULL
  m<- NULL
  rank_mean <- NULL
  for (i in 1:k){
    rank[i]=sum(subset(rank(x),treat==i))##处理内秩和
    m[i]=sum(treat==i)##类内个数
    rank_mean[i] <- rank[i]/m[i]
  }
  # 当数据中存在结点时
  t = as.vector(table(rank(x))) ##计算结点长度
  #当结点存在时，需要对MST,SE进行修正,首先定义一个修正项:correct
  correct = sum(t^3-t)/(12*(n-1))
  mst = n*(n+1)/12-correct
  
  
  #进行比较
  rowname <- NULL
  diff_ij <- NULL
  se_ij <- NULL
  d_ij <-NULL
  p <- NULL
  for (i in 1:(k-1)){
    for (j in (i+1):k){
      diff <- abs(rank_mean[i]-rank_mean[j])
      se <- sqrt(mst*(1/m[i]+1/m[j])) # se = sqrt(MST(1/n_i+1/n_j))
      d = diff/se
      #将结果保存
      diff_ij <- cbind(diff_ij,diff)
      se_ij <- cbind(se_ij,se)
      d_ij <- cbind(d_ij,d)
      p <- cbind(p,1-pnorm(d))
      rowname <- cbind(rowname,paste(i,"VS", j))
      
    }
  }
  
  result_table <- matrix(c(diff_ij,se_ij,d_ij,p),choose(k,2),4,byrow = FALSE)
  rownames(result_table) <- rowname
  colnames(result_table) <- c("|\bar{R_.i}-\bar{R.j}|","SE","d_ij","p")
  result <- list(Table = result_table, alphastar = alphastar,Z=Z)
  return(result)
  
}

```

## 例4.3
```{r}
drug <- c(80,203,236,252,284,368,457,393,133,180,100,160,156,295,320,448,
          465,481,279,194,214,272,330,386,475)
gr.drug <-c(rep(1,8),rep(2,4),rep(3,7),rep(4,6))

kruskal.test(drug,gr.drug)

dunn.test(data = drug,treat=gr.drug,alpha = 0.05)


```

## 例4.4
```{r}
tomato <- c(2.6,2.4,2.9,3.1,2.4,3.1,.9,3.2,2.5,2.8,3.1,2.5,2.2,1.5,1.2,1.4)
gr.tomato <- c(rep(1,5),rep(2,6),rep(3,5))

kruskal.test(tomato,gr.tomato)

dunn.test(tomato,gr.tomato,alpha = 0.05)

```



# Jonckheere–Terpstra统计量
##原理
详细见书p122
第一步：$W_{ij}=样本i中观测值小于样本j中观测值的个数$
第二步：对所有的$W_{ij}$在$i < j$范围求和，由此计算Jonckheere–Terpstra统计量
$J=\sum_{i<j}W_{ij}$
第三步：根据定理4.3，计算p值
```{r}

JT.test<-function(data, treat, ...){
  x = data
  N = length(x) ##查看样本容量
  k = length(unique(treat)) ## 计算组数
  #计算每个组的样本容量
  n<-NULL
  for (i in 1:k){
    n[i] = length(subset(x,treat==i))
  }
  jie = 0 ##先初始化结，当jie = 0时，表示没有结存在，在这里先定义为没有
  # 计算秩
  w_ij = 0
  for (i in 1:(k-1)){
    for (j in (i+1):k){
      xi = subset(x, treat==i)
      xj = subset(x, treat==j)
      for (a in 1:n[i]){
        for (b in 1:n[j]){
          if (xi[a]<xj[b]){
            w_ij = w_ij+1
          }else if(xi[a]==xj[b]){ #处理结存在时的情况
            w_ij = w_ij+1/2
            jie = 1 # 更新结的状态
          }
        }
      }
    }
  }
  J <- w_ij
  # 计算J的期望方差
  ## 期望
  EJ = (N^2 - sum(n^2))/4
  ## 方差
  if (jie==0){
    VarJ = (N^2(2*N+3)-sum(2*(n^3)+3*(n^2)))/72
  }else{
    t = as.vector(table(rank(x)))
    VarJ = 
      ( (N*(N-1)*(2*N+5))  - sum(n*(n-1)*(2*n+5)) - sum(t*(t-1)*(2*t+5)) )/72#第一项 
    +
      1 / (36*N*(N-1)*(N-2)) * (sum(n*(n-1)*(n-2))) * (sum(t*(t-1)*(t-2)))#第二项
    +
      1 / (8*N*(N-1)) * (sum(n*(n-1))) * (sum(t*(t-1)))
  }
  ## 依据J的近似分布计算p值
  
  Z = (J-EJ)/sqrt(VarJ)
  p <- 1-pnorm(Z)
  result <- list(J.Value=J, EJ=EJ, SD=sqrt(VarJ), Z.value=Z, p.value=p)
return(result)
}


```

## 例4.5
```{r}
heart = c(125,136,116,101,105,109,
          122,114,131,120,119,127,
          128,142,128,134,135,131,140,129)
heart.treat = c(rep(1,6),rep(2,6),rep(3,8))
JT.test(heart, heart.treat)

```

## 例4.6
```{r}
jiaoxue=c(40,35,38,43,44,41,
          38,40,47,44,40,42,
          48,40,45,43,46,44)
jiaoxue.treat=c(rep(1,6),rep(2,6),rep(3,6))
JT.test(jiaoxue,jiaoxue.treat)



```

# Friedman方差分析
由于R中自带friedman.test()函数，因此这一部分直接调用该函数
### 例4.7
```{r}
PekingFish <-c(85,82,82,79,
               87,75,86,82,
               90,81,80,76,
               80,75,81,75)
treat.PekingFish <- c(rep(1:4, time=4))
block.PekingFish <- c(rep(1:4, each=4))
friedman.test(PekingFish, treat.PekingFish, block.PekingFish)
```


# Cochran检验
具体原理见书p133
```{r}
cochran.test<-function(data,treat,block,...){
  b = length(unique(block)) #区数
  k = length(unique(treat)) #组数
  y = matrix(NA,k,b)
  for (i in 1:k){
    for (j in 1:b){
      y[i,j]=subset(data,(treat==i)&(block==j))
    }
  }
  nj = apply(y, 1, sum)
  ni = apply(y,2,sum)
  # 计算Q统计量
  Q = ((k-1)*(sum(nj^2)-(sum(nj)*sum(nj))/k))  /  (sum(ni)-sum(ni^2)/k)
  p=1-pchisq(Q,k-1)
  result <- list(Q.value=Q,P.value=p)
return(result)
}
```


```{r}
candid_test =c(0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1,1,1,1,0)
candid.treat = rep(1:3,time=10)
candid.block = rep(1:10, each=3)
cochran.test(candid_test,candid.block,candid.treat)
```
